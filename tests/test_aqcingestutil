#!/usr/bin/env python

# $Id$
# $Rev::                                  $:  # Revision of last commit.
# $LastChangedBy::                        $:  # Author of last commit.
# $LastChangedDate::                      $:  # Date of last commit.

"""
    Test the components of the aqcingestutil package

    Synopsis:
        test_aqcingestutil dbtype [unittest_parameters]

    dbtype must be either "oracle" or "postgres".  A DES services file will
    be found using methods defined in DESDM-3.  The file is expected to
    contain a section named according to dbtype:

        oracle      db-oracle-unittest
        postgres    db-postgres-unittest

    The database user thus identified should have permission to create
    tables within its own schema.

    Any unittest_parameters are passed on to the python unittest module.

    Developed at:
    The National Center for Supercomputing Applications (NCSA).

    Copyright (C) 2012 Board of Trustees of the University of Illinois.
    All rights reserved.

"""

__version__ = "$Rev$"

import copy
import decimal
import numpy
import sys
import unittest
import warnings

from StringIO import StringIO

import coreutils

import aqcingestutil as qc

_DBTYPE = None

def get_type_map (db_type):
    """Return a map from python types to database types."""

    if db_type == 'oracle':
        return {bool   : 'INTEGER',
                float  : 'NUMBER',
                int    : 'INTEGER',
                str    : 'VARCHAR2 (64)',
                unicode: 'VARCHAR2 (64)'
               }
    elif db_type == 'postgres':
        return {bool   : 'INTEGER',
                float  : 'NUMERIC',
                int    : 'INTEGER',
                str    : 'CHARACTER VARYING (64)',
                unicode: 'CHARACTER VARYING (64)'
               }

# Define a mapping from Boolean values to database column values.

_BOOL_MAP = {True: 1, False: 0}

#===============================================================================
# Define a database access class with extensions for testing.
#===============================================================================

class AstromaticQCDBTest (qc.AstromaticQCDB, coreutils.DBTestMixin):
    """
    This is a convenience class.  It adds a few database-related methods used
    by the test cases.
    """

    def __init__ (self, *args, **kwargs):
        qc.AstromaticQCDB.__init__ (self, *args, **kwargs)

    def setup_votables (self, test_data):
        "Populate the database metadata mapping tables with test data."

        # Create and populate the metadata tables.

        tab  = 'metadata_table'
        cols = ['table_name', 'id_column', 'parent_id_column']
        rows = [(val ['table'], val ['id'], val ['fileId'])
                                                for val in test_data.values ()]
        # Create an error condtion.
        rows.append (('extra_id_col', 'id_col2', 'fid_col'))

        #print 'remove use of tmp_metadata_table'
        #self.table_prep_test_copy (tab, 'tmp_metadata_table', cols, rows)
        self.table_prep_test_copy (tab, tab, cols, rows)

        tab  = 'filetype'
        cols = ['filetype', 'metadata_table']
        rows = [(key, val ['table']) for key, val in test_data.items ()]

        #print 'remove use of tmp_filetype'
        #self.table_prep_test_copy (tab, 'tmp_filetype', cols, rows)
        self.table_prep_test_copy (tab, tab, cols, rows)

        tab  = 'metadata'
        cols = ['file_header_name', 'column_name', 'position', 'derived',
                'bands_for_coadd']
        # Pull out all of the fields and their column lists, making sure that
        # all lists for a given field are the same.
        tmpd = {}
        for val in test_data.values ():
            for fld, col_list in val ['fieldMap'].items ():
                if fld in tmpd:
                    if col_list != tmpd [fld]:
                        msg = ('All instances of field "%s" in test data must '
                               'have the same definition.')
                        raise Exception (msg % fld)
                else:
                    tmpd [fld] = col_list
        rows = []
        for fld, col_list in tmpd.items ():
            for pos in range (len (col_list)):
                rows.append ( (fld, col_list [pos], pos, 0, 0) )

        #print 'remove use of tmp_metadata'
        #self.table_prep_test_copy (tab, 'tmp_metadata', cols, rows)
        self.table_prep_test_copy (tab, tab, cols, rows)

        tab  = 'required_metadata'
        cols = ['filetype', 'file_header_name', 'file_segment']
        rows = []
        for key, val in test_data.items ():
            if key == 'MultiTable':
                # Inject an error condition for this VOTable to allow testing
                # of the detection of the error.
                cnt = 0
                for fld in val ['fieldMap']:
                    rows.append ( (key, fld, val ['VOTable'] + str (cnt)) )
                    cnt += 1
            else:
                for fld in val ['fieldMap']:
                    rows.append ( (key, fld, val ['VOTable']) )

        #print "remove use of tmp_required_metadata"
        #self.table_prep_test_copy (tab, 'tmp_required_metadata', cols, rows)
        self.table_prep_test_copy (tab, tab, cols, rows)

#===============================================================================
# Define several data structures containing test data.
#===============================================================================

#-------------------------------------------------------------------------------
# Define a number of VOTable maps using a structure for each that is similar to
# that returned by get_votable_map().  These are used to populate the metadata
# mapping tables and to construct maps that used to test the return value of
# get_votable_map().
#
# Note that the current design of the METADATA table requires that a given
# field have the same definition and mapping regardless of the VOTable from
# which it comes.  This means each occurrence of a field in the following
# structure should have the same value.
#-------------------------------------------------------------------------------

_TEST_METADATA = {
# mapping a single field
'OneField'   : {'VOTable'  : 'OneFieldTab',
                'table'    : 'test_votable_one_field',
                'id'       : 'id_col',
                'fileId'   : 'fid_col',
                'fieldMap' : {'Fld1': ['col1']}
               },
# mapping multiple fields, including multi-valued fields
'ManyField'  : {'VOTable'  : 'ManyFieldTab',
                'table'    : 'test_votable_many_field',
                'id'       : 'id_col',
                'fileId'   : 'fid_col',
                'fieldMap' : {'boolField'    : ['b_col'],
                              'dblArrayField': ['da_col1', 'da_col2'],
                              'fltArrayField': ['fa_col1', 'fa_col2'],
                              'fltField'     : ['f_col'],
                              'intArrayField': ['ia_col1','ia_col2','ia_col3'],
                              'intField'     : ['i_col'],
                              'stringField'  : ['s_col']
#                'fieldMap' : {'Fld1' : ['col1'],
#                              'Fld2' : ['col2'],
#                              'MFld1': ['col3_1', 'col3_2', 'col3_3']
                             }
               },
# a bad field map with two different fields mapped to the same column
'DupColumn'  : {'VOTable'  : 'DupColTab',
                'table'    : 'test_votable_dup_col',
                'id'       : 'id_col',
                'fileId'   : 'fid_col',
                'fieldMap' : {'Fld1' : ['col1'],
                              'Fld3' : ['col1']
                             }
               },
# a bad field map with two values for a multi-valued field mapped to the
# same column
'DupMColumn' : {'VOTable'  : 'DupMColTab',
                'table'    : 'test_votable_dup_mcol',
                'id'       : 'id_col',
                'fileId'   : 'fid_col',
                'fieldMap' : {'MFld2': ['col1_1', 'col1_2', 'col1_1']}
               },
# a bad mapping using multiple VOTable TABLEs; the error condition has to be
# created when the test data is loaded since this data structure doesn't
# allow it, but the database tables do.
'MultiTable' : {'VOTable'  : 'MultipleTab',
                'table'    : 'test_multi_votable',
                'id'       : 'id_col',
                'fileId'   : 'fid_col',
                'fieldMap' : {'Fld1' : ['col1'],
                              'Fld2' : ['col2']
                             }
               },
# a bad mapping with a missing column name.
'MissColName': {'VOTable'  : 'MissingColumnName',
                'table'    : 'missing_col_tab',
                'id'       : 'id_col',
                'fileId'   : 'fid_col',
                'fieldMap' : {'Fld5': [None]}
               },
# a bad mapping with a missing database table name.
'MissDBTable': {'VOTable'  : 'MissingTable',
                'table'    : None,
                'id'       : 'id_col',
                'fileId'   : 'fid_col',
                'fieldMap' : {'Fld1': ['col1']}
               },
# a bad mapping with a missing file id column.
'MissFIdCol' : {'VOTable'  : 'MissingFIdColumn',
                'table'    : 'missing_fid_tab',
                'id'       : 'id_col',
                'fileId'   : None,
                'fieldMap' : {'Fld1': ['col1']}
               },
# a bad mapping with a missing header name.
'MissHdrName': {'VOTable'  : 'MissingHdrName',
                'table'    : 'missing_hdr_tab',
                'id'       : 'id_col',
                'fileId'   : 'fid_col',
                'fieldMap' : {None: ['col1']}
               },
# a bad mapping with a missing id column.
'MissIdCol'  : {'VOTable'  : 'MissingIdColumn',
                'table'    : 'missing_id_tab',
                'id'       : None,
                'fileId'   : 'fid_col',
                'fieldMap' : {'Fld1': ['col1']}
               },
# a bad mapping with a missing VOTable table name (file segment).
'MissVOTable': {'VOTable'  : None,
                'table'    : 'missing_votable',
                'id'       : 'id_col',
                'fileId'   : 'fid_col',
                'fieldMap' : {'Fld1': ['col1']}
               },
# a placeholder for a bad mapping with multiple id columns.  The error is
# introduced when loading the test data.
'ExtraIdCol' : {'VOTable'  : 'ExtraIdCol1',
                'table'    : 'extra_id_col',
                'id'       : 'id_col',
                'fileId'   : 'fid_col',
                'fieldMap' : {'Fld4': ['col4']}
               }
}

#-------------------------------------------------------------------------------
# Construct a dictionary of maps that should correspond to return values from
# get_votable_map() for the source structure defined above.
#-------------------------------------------------------------------------------

_TEST_MAP = copy.deepcopy (_TEST_METADATA)
del _TEST_MAP ['DupColumn']
del _TEST_MAP ['DupMColumn']

def _def_columns (vmap):
    'Construct "columns" entries for each map.'
    for vot in vmap:
        fmap = vmap [vot]['fieldMap']
        cols = [vmap [vot]['id'], vmap [vot]['fileId']]
        for fld in sorted (fmap.keys ()):
            for col in fmap [fld]:
                cols.append (col)
        vmap [vot]['columns'] = cols
_def_columns (_TEST_MAP)

#-------------------------------------------------------------------------------
# Define a set of test values
#
# keys:
# fid: file id expected to accompany the set of data values
# built: expected results of build_rows ()
# votable: expected results from get_table_data ()
#-------------------------------------------------------------------------------

_TEST_VALUES = {
    'ManyField' :
        {'fid'    : 23400,
         'built'  : [{'id_col': 23401, 'fid_col': 23400, 'b_col': 0,
                      'da_col1': 33.99997288, 'da_col2': -6.925795058e-06,
                      'fa_col1': -0.00202384, 'fa_col2': -0.000234789,
                      'f_col': 4.47325e-05, 'ia_col1': 9, 'ia_col2': 8,
                      'ia_col3': 7, 'i_col': 234, 's_col': 'some string'
                     }
                    ],
         'votable': numpy.rec.array ([[False, [33.99997288, -6.925795058e-06],
                     [numpy.float32(-0.00202384), numpy.float32(-0.000234789)],
                     numpy.float32 (4.47325e-05), [9, 8, 7],
                     234, 'some string' ]],
                     dtype=[('boolField', bool), ('dblArrayField', 'f8', (2, )),
                     ('fltArrayField', 'f4', (2, )), ('fltField', 'f4'),
                     ('intArrayField', 'i4', (3, )), ('intField', 'i4'),
                     ('stringField','|S32')])
        },
    # This is meant to be used with ManyField map for testing detection of
    # different previously ingested data.
    'ManyFieldDifferent' :
        {'fid'    : 23400,
         'built'  : [{'id_col': 23401, 'fid_col': 23400, 'b_col': 0,
                      'da_col1': 44.44444444, 'da_col2': -6.925795058e-06,
                      'fa_col1': -0.00202384, 'fa_col2': -0.000234789,
                      'f_col': 4.47325e-05, 'ia_col1': 9, 'ia_col2': 8,
                      'ia_col3': 7, 'i_col': 234, 's_col': 'some string'
                     }
                    ]
        },
    # This is meant to be used with ManyField map for testing detection of too
    # few values for a multi-valued field.
    'ManyFieldLessMulti' :
        {'votable': numpy.rec.array ([[False, [33.99997288, -6.925795058e-06],
                     [numpy.float32(-0.00202384), numpy.float32(-0.000234789)],
                     numpy.float32 (4.47325e-05), [9, 8],
                     234, 'some string' ]],
                     dtype=[('boolField', 'b'), ('dblArrayField', 'f8', (2, )),
                     ('fltArrayField', 'f4', (2, )), ('fltField', 'f4'),
                     ('intArrayField', 'i4', (2, )), ('intField', 'i4'),
                     ('stringField','|S32')])
        },
    # This is meant to be used with ManyField map for testing detection of too
    # many values for a multi-valued field.
    'ManyFieldMoreMulti' :
        {'votable': numpy.rec.array ([[False, [33.99997288, -6.925795058e-06],
                     [numpy.float32(-0.00202384), numpy.float32(-0.000234789)],
                     numpy.float32 (4.47325e-05), [9, 8, 7, 6],
                     234, 'some string' ]],
                     dtype=[('boolField', 'b'), ('dblArrayField', 'f8', (2, )),
                     ('fltArrayField', 'f4', (2, )), ('fltField', 'f4'),
                     ('intArrayField', 'i4', (4, )), ('intField', 'i4'),
                     ('stringField','|S32')])
        },
    # This is meant to be used with ManyField map for testing detection of too
    # many values for a single-valued field.
    'ManyFieldMoreSingle' :
        {'votable': numpy.rec.array ([[False, [33.99997288, -6.925795058e-06],
                     [numpy.float32(-0.00202384), numpy.float32(-0.000234789)],
                     numpy.float32 (4.47325e-05), [9, 8, 7],
                     234, 'some string' ]],
                     dtype=[('boolField', 'b'), ('dblArrayField', 'f8', (2, )),
                     ('fltArrayField', 'f4', (2, )), ('fltField', 'f4', (2, )),
                     ('intArrayField', 'i4', (3, )), ('intField', 'i4'),
                     ('stringField','|S32')])
        },
    # This is meant to be used with ManyField map for testing building with
    # null values; these cannot be constructed in numpy so this test only
    # applies to building rows from built in python types.
    'ManyFieldNone' :
        {'built'  : [{'id_col': 23401, 'fid_col': 23400, 'b_col': 0,
                      'da_col1': 33.99997288, 'da_col2': None,
                      'fa_col1': -0.00202384, 'fa_col2': -0.000234789,
                      'f_col': 4.47325e-05, 'ia_col1': 9, 'ia_col2': 8,
                      'ia_col3': 7, 'i_col': None, 's_col': None
                     }
                    ],
         'votable': [{'boolField': False, 'dblArrayField': [33.99997288, None],
                      'fltArrayField': [-0.00202384, -0.000234789],
                      'fltField' : 4.47325e-05, 'intArrayField': [9, 8, 7],
                      'intField': None, 'stringField': None}]
        }
}

#-------------------------------------------------------------------------------
# Define a sequence of VOTable XML files used for testing ingest().  Some of
# files correspond to entries in the test data above, but some do not for
# testing purposes.
#-------------------------------------------------------------------------------

_TEST_FILES = [
"""
<VOTABLE version="1.1" xmlns="http://www.ivoa.net/xml/VOTable/v1.1">
<DESCRIPTION>This is a sample file for testing purposes.</DESCRIPTION>
<RESOURCE ID="ManyField" name="SomeResourceName">
  <DESCRIPTION>
    The ID from the top-level RESOURCE tag is used to identify the type of
    VOTable QC data to be ingested.
  </DESCRIPTION>
  <RESOURCE ID="MetaData">
    <DESCRIPTION>The QC files typically have data tables here.</DESCRIPTION>
    <TABLE ID="ManyFieldTab" name="table1name">
      <FIELD name="boolField" datatype="boolean" ucd="meta.code"/>
      <FIELD name="dblArrayField" datatype="double" arraysize="2" ucd="pos.eq"
                                                                  unit="deg"/>
      <FIELD name="fltArrayField" datatype="float" arraysize="2"
                                               ucd="instr.pixel" unit="arcsec"/>
      <FIELD name="fltField" datatype="float" ucd="phot.mag" unit="mag"/>
      <FIELD name="intArrayField" datatype="int" arraysize="3"
                                                           ucd="meta.number"/>
      <FIELD name="intField" datatype="int" ucd="meta.number"/>
      <FIELD name="stringField" datatype="char" arraysize="*" ucd="meta.file"/>
      <DATA>
        <TABLEDATA>
          <TR>
            <TD>F</TD><TD>33.99997288 -6.925795058e-06</TD>
            <TD>-0.00202384 -0.000234789</TD><TD>4.47325e-05</TD><TD>9 8 7</TD>
            <TD>234</TD><TD>some string</TD>
          </TR>
          <!-- The following row is present to test that the ingest procedures
               ignore it. -->
          <TR>
            <TD>T</TD><TD>0 0</TD><TD>0 0</TD><TD>0</TD><TD>0 0 0</TD>
            <TD>0</TD><TD></TD>
          </TR>
        </TABLEDATA>
      </DATA>
    </TABLE>
  </RESOURCE>
</RESOURCE>
</VOTABLE>
""",
"""
<VOTABLE version="1.1" xmlns="http://www.ivoa.net/xml/VOTable/v1.1">
<DESCRIPTION>This is a sample file with an unknown id.</DESCRIPTION>
<RESOURCE ID="NoSuchThing" name="SomeResourceName">
  <RESOURCE ID="MetaData">
    <TABLE ID="SomeTab" name="table1name">
      <FIELD name="boolField" datatype="boolean" ucd="meta.code"/>
      <DATA>
        <TABLEDATA>
          <TR>
            <TD>F</TD>
          </TR>
        </TABLEDATA>
      </DATA>
    </TABLE>
  </RESOURCE>
</RESOURCE>
</VOTABLE>
"""
]


#===============================================================================
# Define a test suite for the DB access class.
#===============================================================================

class TestAstromaticQCDB (unittest.TestCase):
    """Test the AstromaticQCDB class."""

    @classmethod
    def setUpClass (cls):
        # Open a connection for use by all tests.  This opens the possibility of
        # tests interfering with one another, but connecting for each test
        # seems a bit excessive.

        if _DBTYPE == 'oracle':
            cls.test_section = 'db-oracle-unittest'
        elif _DBTYPE == 'postgres':
            cls.test_section = 'db-postgres-unittest'

        cls.dbh = AstromaticQCDBTest (section=cls.test_section)

        # Create test tables, sequences, etc. and populate with test data.

        cls.dbh.setup_votables (_TEST_METADATA)
        cls.dbh.commit ()

        # Define a map from python types to database types.

        cls.type_map = get_type_map (_DBTYPE)

    @classmethod
    def tearDownClass (cls):
        cls.dbh.table_drop ('required_metadata')
        cls.dbh.table_drop ('metadata')
        cls.dbh.table_drop ('filetype')
        cls.dbh.table_drop ('metadata_table')

        cls.dbh.commit ()
        cls.dbh.close ()

    def setUp (self):
        self.maxDiff = None

    def test_build_rows (self):
        "Build ingestable rows from a numpy array."

        vid = 'ManyField'
        fid = _TEST_VALUES [vid]['fid']
        data_in = _TEST_VALUES [vid]['votable']
        data_out = _TEST_VALUES [vid]['built']
        vmap = _TEST_MAP ['ManyField']
        rows = self.dbh.build_rows (vmap, fid, data_in, _BOOL_MAP)
        self.assertTrue (*qc.compare_rounded (rows, data_out))

    def test_build_rows_no_BOOL_MAP (self):
        "Test reporting of Missing boolean map."

        vid = 'ManyField'
        fid = _TEST_VALUES [vid]['fid']
        data_in = _TEST_VALUES [vid]['votable']

        with self.assertRaises (qc.MissingBooleanMapError):
            self.dbh.build_rows (_TEST_MAP ['ManyField'], fid, data_in)

    def test_build_rows_missing_field (self):
        "Test detection of missing field."

        fid = 23400
        data_in =  [{'Fld2' : 's1', 'MFld1': [1, 2, 3]}]
        with self.assertRaises (qc.MissingFieldError):
            self.dbh.build_rows (_TEST_MAP ['ManyField'], fid, data_in)

    def test_build_rows_too_few_multi (self):
        "Test detection of too few values for a multi-valued field."

        fid = _TEST_VALUES ['ManyField']['fid']
        data_in = _TEST_VALUES ['ManyFieldLessMulti']['votable']
        with self.assertRaises (qc.ValueCountError):
            self.dbh.build_rows (_TEST_MAP ['ManyField'], fid, data_in)

    def test_build_rows_too_many_multi (self):
        "Test detection of too many values for a multi-valued field."

        fid = _TEST_VALUES ['ManyField']['fid']
        data_in = _TEST_VALUES ['ManyFieldMoreMulti']['votable']
        with self.assertRaises (qc.ValueCountError):
            self.dbh.build_rows (_TEST_MAP ['ManyField'], fid, data_in)

    def test_build_rows_too_many_single (self):
        "Test detection of too many values for a single-valued field."

        fid = _TEST_VALUES ['ManyField']['fid']
        data_in = _TEST_VALUES ['ManyFieldMoreSingle']['votable']
        with self.assertRaises (qc.ValueCountError):
            self.dbh.build_rows (_TEST_MAP ['ManyField'], fid, data_in)

    def test_build_rows_with_nulls (self):
        "Test acceptance of null values."

        vid = 'ManyField'
        fid = _TEST_VALUES [vid]['fid']
        data_in = _TEST_VALUES ['ManyFieldNone']['votable']
        data_out = _TEST_VALUES ['ManyFieldNone']['built']
        vmap = _TEST_MAP ['ManyField']
        rows = self.dbh.build_rows (vmap, fid, data_in, _BOOL_MAP)
        self.assertTrue (*qc.compare_rounded (rows, data_out))

    def test_get_existing_rows (self):
        "Get previously ingested rows."

        vid = 'ManyField'
        vmap = _TEST_MAP [vid]

        fid = _TEST_VALUES [vid]['fid']
        rows_in = _TEST_VALUES [vid]['built']
        cols = vmap ['columns']
        types = [self.type_map [type (rows_in[0][col])] for col in cols]

        with self.dbh.table_recreate (vmap ['table'], cols, types):
            self.dbh.insert_many (vmap ['table'], cols, rows_in)
            rows_out = self.dbh.get_existing_rows (vmap, fid)
            self.assertTrue (*qc.compare_rounded (rows_in, rows_out))

    def test_get_map_duplicate_column (self):
        "Test detection of two fields mapped to the same column."

        with self.assertRaises (qc.DuplicateColumnError):
            self.dbh.get_votable_map ('DupColumn')

    def test_get_map_duplicate_mcolumn (self):
        "Test detection of multi-valued field mapped to the same column twice."

        with self.assertRaises (qc.DuplicateColumnError):
            self.dbh.get_votable_map ('DupMColumn')

    def test_get_map_many_field (self):
        vmap = self.dbh.get_votable_map ('ManyField')
        self.assertEqual (vmap, _TEST_MAP ['ManyField'])

    def test_get_map_missing_column (self):
        "Test detection of missing database table column name."

        with self.assertRaises (qc.MissingColumnNameError):
            self.dbh.get_votable_map ('MissColName')

    def test_get_map_missing_db_table (self):
        "Test detection of missing database table name."

        with self.assertRaises (qc.MissingDBTableError):
            self.dbh.get_votable_map ('MissDBTable')

    def test_get_map_missing_file_id_column (self):
        "Test detection of missing database table file id column."

        with self.assertRaises (qc.MissingFileIdColumnError):
            self.dbh.get_votable_map ('MissFIdCol')

    def test_get_map_missing_header_name (self):
        "Test detection of missing file header name."

        with self.assertRaises (qc.MissingHeaderNameError):
            self.dbh.get_votable_map ('MissHdrName')

    def test_get_map_missing_id_column (self):
        "Test detection of missing database table id column."

        with self.assertRaises (qc.MissingIdColumnError):
            self.dbh.get_votable_map ('MissIdCol')

    def test_get_map_missing_votable (self):
        "Test detection of missing VOTable table name."

        with self.assertRaises (qc.MissingFileSegmentError):
            self.dbh.get_votable_map ('MissVOTable')

    def test_get_map_multiple_id_column (self):
        "Test detection of multiple id columns for a database table."

        with self.assertRaises (qc.MultipleIdColumnsError):
            self.dbh.get_votable_map ('ExtraIdCol')

    def test_get_map_multiple_votable (self):
        "Test detection of references to multiple VOTable TABLE entities."

        with self.assertRaises (qc.MultipleTableError):
            self.dbh.get_votable_map ('MultiTable')

    def test_get_map_one_field (self):
        vmap = self.dbh.get_votable_map ('OneField')
        self.assertEqual (vmap, _TEST_MAP ['OneField'])

    def test_get_map_unknown_votable (self):
        "Test reporting of a non-existent VOTable."

        self.assertEqual (self.dbh.get_votable_map ('UnknownVOTable'), None)

    def test_ingest_rows (self):
        "Test ingestion of some rows."

        vid = 'ManyField'
        vmap = _TEST_MAP [vid]

        rows_in = _TEST_VALUES [vid]['built']
        cols = vmap ['columns']
        types = [self.type_map [type (rows_in[0][col])] for col in cols]

        with self.dbh.table_recreate (vmap ['table'], cols, types):
            self.dbh.ingest_rows (vmap, rows_in)
            rows_out = self.dbh.query_simple (vmap ['table'], vmap ['columns'],
                                              orderby = 'id_col')
            self.assertTrue (*qc.compare_rounded (rows_in, rows_out))


#===============================================================================
# Define a test suite for the VOTable access class.
#===============================================================================

class TestQCVOTable (unittest.TestCase):
    """Test the QCVOTable class."""

    @classmethod
    def setUpClass (cls):
        cls.votable_file = StringIO (_TEST_FILES [0])

    @classmethod
    def tearDownClass (cls):
        cls.votable_file.close ()

    def setUp (self):
        self.votable_file.seek (0)

    def test_open (self):
        "Test opening the test file without exception."

        self.assertIsNotNone (qc.QCVOTable (self.votable_file))

    def test_qc_type (self):
        "Check for expected QC type."

        vot = qc.QCVOTable (self.votable_file)
        self.assertEqual (vot.get_qc_type (), 'ManyField')
    def test_get_table (self):
        "Test retrieval of a table."

        vot = qc.QCVOTable (self.votable_file)
        tab = vot.get_table ('ManyFieldTab')
        self.assertIsNotNone (tab)
        self.assertEqual (tab.ID, 'ManyFieldTab')

    def test_get_table_data (self):
        """Test retrieval of data from a table."""
        vot = qc.QCVOTable (self.votable_file)
        data = vot.get_table_data ('ManyFieldTab')
        data = data.tolist ()
        func = lambda fld: fld.tolist () if hasattr (fld, 'tolist') else fld
        data = [[func (fld) for fld in row] for row in data]
        expected = [[False, [33.99997288, -6.925795058e-06],
                    [numpy.float32 (-0.00202384), numpy.float32 (-0.000234789)],
                    numpy.float32 (4.47325e-05), [9, 8, 7],
                    234, 'some string'
                   ]]
        self.assertEqual (data, expected)

#===============================================================================
# Define a test suite for the ingest().
#===============================================================================

class TestIngest (unittest.TestCase):
    """Test the main ingest() function."""

    @classmethod
    def setUpClass (cls):
        cls.votable_file = StringIO (_TEST_FILES [0])

        if _DBTYPE == 'oracle':
            cls.test_section = 'db-oracle-unittest'
        elif _DBTYPE == 'postgres':
            cls.test_section = 'db-postgres-unittest'

        cls.dbh = AstromaticQCDBTest (section=cls.test_section)

        # Add some test data.  Be sure to commit so that ingest() can see the
        # data from its own database connection.

        cls.dbh.setup_votables (_TEST_METADATA)
        cls.dbh.commit ()

        # Define a map from python types to database types.

        cls.type_map = get_type_map (_DBTYPE)

        # Make the re-ingest warning an error for testing purposes.

        warnings.simplefilter ('error', qc.ReingestWarning)

    @classmethod
    def tearDownClass (cls):
        cls.votable_file.close ()

        cls.dbh.table_drop ('required_metadata')
        cls.dbh.table_drop ('metadata')
        cls.dbh.table_drop ('filetype')
        cls.dbh.table_drop ('metadata_table')

        cls.dbh.commit ()
        cls.dbh.close ()

    def setUp (self):
        self.votable_file.seek (0)

    def test_ingest (self):
        "Test ingest of VOTable file."

        vid = 'ManyField'
        vmap = _TEST_MAP [vid]

        fid = _TEST_VALUES [vid]['fid']
        expected = _TEST_VALUES [vid]['built']
        cols = vmap ['columns']
        types = [self.type_map [type (expected[0][col])] for col in cols]

        with self.dbh.table_recreate (vmap ['table'], cols, types):
            self.dbh.commit () # Make table visible to ingest()'s connection.
            qc.ingest (self.votable_file, fid, self.test_section, _BOOL_MAP)
            rows_out = self.dbh.query_simple (vmap ['table'], cols)
            self.assertTrue (*qc.compare_rounded (expected, rows_out))

    def test_ingest_bad_votable_id (self):
        "Test ingest of VOTable file with an unknown votable id."

        votable_file = StringIO (_TEST_FILES [1])

        with self.assertRaises (qc.UnknownQCType):
            qc.ingest (votable_file, 0, self.test_section)

    def test_ingest_reingest_bad (self):
        "Test re-ingest of VOTable file with different data."

        vid = 'ManyField'
        vmap = _TEST_MAP [vid]

        fid = _TEST_VALUES [vid]['fid']
        expected = _TEST_VALUES [vid]['built']
        cols = vmap ['columns']
        types = [self.type_map [type (expected[0][col])] for col in cols]
        rows_in = _TEST_VALUES ['ManyFieldDifferent']['built']

        with self.dbh.table_recreate (vmap ['table'], cols, types):
            self.dbh.insert_many (vmap ['table'], cols, rows_in)
            self.dbh.commit () # Make table visible to ingest()'s connection.
            with self.assertRaises (qc.ReingestError):
                qc.ingest (self.votable_file, fid, self.test_section, _BOOL_MAP)
            # Check that no changes have been made.
            rows_out = self.dbh.query_simple (vmap ['table'], cols)
            self.assertTrue (*qc.compare_rounded (rows_in, rows_out))

    def test_ingest_reingest_same (self):
        "Test re-ingest of VOTable file with the same data."

        vid = 'ManyField'
        vmap = _TEST_MAP [vid]

        fid = _TEST_VALUES [vid]['fid']
        expected = _TEST_VALUES [vid]['built']
        cols = vmap ['columns']
        types = [self.type_map [type (expected[0][col])] for col in cols]

        with self.dbh.table_recreate (vmap ['table'], cols, types):
            self.dbh.insert_many (vmap ['table'], cols, expected)
            self.dbh.commit () # Make table visible to ingest()'s connection.
            with self.assertRaises (qc.ReingestWarning):
                qc.ingest (self.votable_file, fid, self.test_section, _BOOL_MAP)
            rows_out = self.dbh.query_simple (vmap ['table'], cols)
            self.assertTrue (*qc.compare_rounded (expected, rows_out))

#===============================================================================
# Define a test suite for compare_rounded ().
#===============================================================================

class TestCompareRounded (unittest.TestCase):
    """Test compare_rounded()."""

    def test_boolean (self):
        """Identical Boolean value should not be different."""
        self.assertEqual (qc.compare_rounded (True, True), (True, None))

    def test_boolean_not_equal (self):
        """Different Boolean values should be reported."""
        res = (False, 'True != False')
        self.assertEqual (qc.compare_rounded (True, False), res)

    def test_dict (self):
        """Identical dictionaries should match."""
        ita = {'k1': 1, 'k2': 'a'}
        self.assertEqual (qc.compare_rounded (ita, ita), (True, None))

    def test_dict_list (self):
        """Identical lists in dictionaries should match."""
        ita = {'k1': ['a']}
        self.assertEqual (qc.compare_rounded (ita, ita), (True, None))

    def test_dict_list_not_equal (self):
        """Differences in lists in dictionaries should be detected."""
        ita = {'k1': ['a']}
        itb = {'k1': ['b']}
        res = (False, {'Key "k1" differs': {'Entry 0 differs': "'a' != 'b'"}})
        self.assertEqual (qc.compare_rounded (ita, itb), res)

    def test_dict_multiple (self):
        """Multiple differences between dictionaries should be reported."""
        ita = {'k1': 0}
        itb = {'k1': 1, 'k2': 'a'}
        res = (False,
               {"Extra keys in B": ['k2'], 'Key "k1" differs': '0 != 1'})
        self.assertEqual (qc.compare_rounded (ita, itb), res)

    def test_dict_not_equal (self):
        """A Single key difference should be reported."""
        ita = {'k1': 1, 'k2': 'a'}
        itb = {'k1': 0, 'k2': 'a'}
        res = (False, {'Key "k1" differs': "1 != 0"})
        self.assertEqual (qc.compare_rounded (ita, itb), res)

    def test_dict_scalar (self):
        """Comparing a dictionary to a scalar should report a difference."""
        ita = {'k1': ['a']}
        itb = 'k1'
        res = (False, "{'k1': ['a']} != 'k1'")
        self.assertEqual (qc.compare_rounded (ita, itb), res)

    def test_dict_short_a (self):
        """First dictionary with fewer keys should be reported."""
        ita = {'k1': 1}
        itb = {'k1': 1, 'k2': 'a'}
        res = (False, {"Extra keys in B": ['k2']})
        self.assertEqual (qc.compare_rounded (ita, itb), res)

    def test_dict_short_b (self):
        """Second dictionary with fewer keys should be reported."""
        ita = {'k1': 1, 'k2': 'a'}
        itb = {'k1': 1}
        res = (False, {"Extra keys in A": ['k2']})
        self.assertEqual (qc.compare_rounded (ita, itb), res)

    def test_dict_short_many (self):
        """Multiple key differences should be reported."""
        ita = {'k1': 1, 'k2': 'a', 'k3': 'b', 'k4': True}
        itb = {'k1': 1}
        res = (False, {"Extra keys in A": ['k2', 'k3', 'k4']})
        self.assertEqual (qc.compare_rounded (ita, itb), res)

    def test_empty_string (self):
        """Two empty strings should match."""
        self.assertEqual (qc.compare_rounded ('', ''), (True, None))

    def test_empty_string_not_equal (self):
        """Comparing a string to an empty string should report a difference."""
        self.assertEqual (qc.compare_rounded ('', 'a'), (False, "'' != 'a'"))

    def test_list (self):
        """Two identical lists should match."""
        ita = [1, 'a']
        self.assertEqual (qc.compare_rounded (ita, ita), (True, None))

    def test_list_dict (self):
        """Two identical lists with dicitionaries should match."""
        ita = [{'k1': 'a'}]
        self.assertEqual (qc.compare_rounded (ita, ita), (True, None))

    def test_list_dict_not_equal (self):
        """Lists containing different dictionaries should be reported."""
        ita = [{'k1': 'a'}]
        itb = [{'k1': 'b'}]
        res = (False, {'Entry 0 differs': {'Key "k1" differs': "'a' != 'b'"}})
        self.assertEqual (qc.compare_rounded (ita, itb), res)

    def test_list_not_equal (self):
        """Different simple list entries should be reported."""
        ita = [1, 'a']
        itb = [1, 'b']
        res = (False, {'Entry 1 differs': "'a' != 'b'"})
        self.assertEqual (qc.compare_rounded (ita, itb), res)

    def test_list_scalar (self):
        """A list and a scalar should result in a difference report."""
        ita = ['a']
        itb = 'a'
        res = (False, "['a'] != 'a'")
        self.assertEqual (qc.compare_rounded (ita, itb), res)

    def test_list_short_a (self):
        """A missing entry in the first list should be reported."""
        ita = [1]
        itb = [1, 'a']
        res = (False, {'Extra entries in B': ['a']})
        self.assertEqual (qc.compare_rounded (ita, itb), res)

    def test_list_short_b (self):
        """A missing entry in the second list should be reported."""
        ita = [1, 'a']
        itb = [1]
        res = (False, {'Extra entries in A': ['a']})
        self.assertEqual (qc.compare_rounded (ita, itb), res)

    def test_list_short_many (self):
        """Several missing list entries should be reported."""
        ita = [1, 'a', 'b', True]
        itb = [1]
        res = (False, {'Extra entries in A': ['a', 'b', True]})
        self.assertEqual (qc.compare_rounded (ita, itb), res)

    def test_none (self):
        """None should match itself."""
        self.assertEqual (qc.compare_rounded (None, None), (True, None))

    def test_none_not_equal (self):
        """None should not match a string."""
        self.assertEqual (qc.compare_rounded (None, ''), (False, "None != ''"))

    def test_scalar_decimal_match (self):
        """A rounded Decimal should match."""
        d1 = decimal.Decimal (1.6)
        d2 = decimal.Decimal (1.59999999)
        self.assertEqual (qc.compare_rounded (d1, d2), (True, None))

    def test_scalar_decimal_nomatch (self):
        """Differing Decimal's should be reported."""
        d1 = decimal.Decimal (1.6)
        d2 = decimal.Decimal (1.5999999)
        res = (False,"Decimal('"
                     "1.600000000000000088817841970012523233890533447265625')"
                     " != Decimal('"
                     "1.5999999000000000304311242871335707604885101318359375')")
        self.assertEqual (qc.compare_rounded (d1, d2), res)

    def test_scalar_decimal_float_match (self):
        """A rounded Decimal should match an equivalent float."""
        d1 = decimal.Decimal (1.6)
        d2 = 1.59999999
        self.assertEqual (qc.compare_rounded (d1, d2), (True, None))

    def test_scalar_float_match (self):
        """A rounded float should match."""
        self.assertEqual (qc.compare_rounded (1.6, 1.59999999), (True, None))

    def test_scalar_float_no_match (self):
        """Differing floats should be reported."""
        res = (False, '1.6 != 1.5999999')
        self.assertEqual (qc.compare_rounded (1.6, 1.5999999), res)

    def test_scalar_int (self):
        """An integer should match itself."""
        self.assertEqual (qc.compare_rounded (1, 1), (True, None))

    def test_scalar_int_not_equal (self):
        """Differing integers should be reported."""
        self.assertEqual (qc.compare_rounded (1, 2), (False, '1 != 2'))

    def test_scalar_string (self):
        """A string should match itself."""
        self.assertEqual (qc.compare_rounded ('a', 'a'), (True, None))

    def test_tuple (self):
        """A tuple should match itself."""
        ita = (1, 'a')
        self.assertEqual (qc.compare_rounded (ita, ita), (True, None))

    def test_tuple_not_equal (self):
        """Differing tuples should be reported."""
        ita = (1, 'a')
        itb = (1, 'b')
        res = (False, {'Entry 1 differs': "'a' != 'b'"})
        self.assertEqual (qc.compare_rounded (ita, itb), res)


if __name__ == '__main__':
    if sys.hexversion < 0x02070000:
        sys.exit (sys.argv [0] + ': Error: Python version >= 2.7 and < 3.0 '
                  'required.')

    USAGE = 'Usage: %s oracle|postgres [unittest_args...]' % sys.argv [0]

    try:
        _DBTYPE = sys.argv [1]
    except IndexError:
        sys.exit (USAGE)

    if _DBTYPE not in ['oracle', 'postgres']:
        sys.exit (USAGE)

    del sys.argv [1]

    unittest.main ()
